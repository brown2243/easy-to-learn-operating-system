# 프로세스 동기화

- 24/06/04 사당 투썸

## 1. 프로세스 간 통신

### 프로세스간 통신의 개념

- 프로세스간의 통신을 IPC(inter process communication)라고 지칭

  - 공유 메모리, 공유 파일을 이용
    - 데이터를 주고 받는 방식을 프로세스가 알아서 결정해야 하기에 가장 원시적
  - 파이프를 이용한 통신
    - 하나의 컴퓨터내에서 가장 많이 사용되는 방식
    - 운영체제가 제공하는 통신 기법
    - 파이프는 fork로 생성한 부모-자식 간 통신에 사용
  - 소켓을 이용한 통신
    - 네트워크로 연결된 경우에 사용되는 수단
    - 같은 컴퓨터에서도 사용가능하나 비효율

- 통신은 간단하게 보면 데이터를 주고 받는 것
  - 통신대상을 어떻게 식별, 데이터 사이즈, 도착여부등의 문제를 해결해야 함

### 프로세스 간 통신의 분류

- 양방향: 일반적인 통신은 양방향, 소켓
- 반양방향: 동시전송 불가, 무전기
- 단방향: 한쪽방향, 모스부호, 파이프, 공유 메모리,파일 방식

- 데이터를 받는 쪽이 계속 확인을 해야한다면 바쁜대기라고 함(폴링이랑 유사)
- 데이터가 도착했음을 알려주는 것은 동기화
- 대기가 있는 통신: 동기화 통신(파이프, 소켓, 전화)
- 대기가 없는 통신: 비동기화 통신(공유메모리, 전보)

### 프로세스 간 통신의 종류

- 파일을 이용한 통신
  - 파일 입출력은 세부분으로 구성(열기, 쓰기, 읽기)
  - open 함수로 fd(file descripter)를 얻은 후 이를 이용해 파일에 접근
  - 운영체제 입장에선 파일 입출력도 일반 프로세스와 입출력 프로세스간의 통신이다.
- 파이프를 이용한 통신
  - 운영체제가 지원하는 동기화 방식
  - 단방향(양방향은 파이프 2개 필요)
  - 이름 없는 파이프: 일반적 경우, 부모 자식 프로세스처럼 관련있는 프로세스 간에 사용
  - 이름 있는 파이프: FIFO라는 특수 파일을 이용해 관련 없는 프로세스 간에 사용
- 소켓을 이용한 통신
  - IP 프로토콜의 목적은 목적지(상대 컴퓨터)까지 데이터를 전송하는 것
  - port: 네트워크를 사용하는 프로세스를 구분하기 위해 사용하는 주소(0 ~ 65535)
    - 하나의 포트에 여러 클라이언트를 연결하려면 소켓이 필요
  - 네트워크에서 데이터를 보낸다는 것은 클라이언트 소켓이 서버 소켓에게 데이터를 보내는 것

## 2. 공유 자원과 임계구역

프로세스는 독립적으로 작업할 수도, 공유된 자원을 사용할 수도 있다.

### 공유 자원에 대한 접근

- 공유 자원: 여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일등
- 경쟁 조건(race condition): 2개 이상의 프로세스가 공유 자원을 동시에 읽거나 쓰는 상황
  - 접근 순서에 따라 결과가 달라질 수 있음

### 임계구역

- 임계구역: 공유자원 접근 순서에 따라 결과가 달라질 수 프로그램 영역

### 생산자 - 소비자 문제

- 생산자 소비자 문제: 임계구역에 관련한 전통적인 문제
  - 생산자 프로세스는 데이터 삽입 & sum 증가
  - 소비자 프로세스는 데이터 제거 & sum 감소
  - 각 프로세스가 독립적인 상황에서 현재값을 읽어 업데이트를 동시에 진행하면 실행 순서에 따라 sum 값이 달라질 수 있음

### 임계구역 문제 해결 조간

- 상호 배제: 한 프로세스가 진입하면, 타 프로세스 진입불가
- 한정 대기: 무한대기 하면 안됨
- 진행 융통성: 타 프로세스의 진행을 방해해선 안됨

## 3. 임계구역 문제 해결 방법

- 단순한 방법은 잠금을 사용하는 것

### 피터슨 알고리즘

- 두 개의 프로세스만 다룰 수 있음
- flag 배열은 각 프로세스의 진입 의사를 나타냄
- turn 변수는 현재 누구의 차례인지를 나타냄
- 상호 배제, 진행, 한정 대기 조건을 모두 만족함

### 데커 알고리즘

- 피터슨 알고리즘과 마찬가지로 두 개의 프로세스만 다룰 수 있음(변수가 계속 추가)
- flag 배열과 turn 변수를 사용.
- 피터슨 알고리즘보다 더 복잡한 로직을 사용하여 상호 배제를 보장합니다.

- 위 두 알고리즘은 현대의 운영체제에서는 직접 사용되지 않고, 주로 교육 목적으로 사용

### 세마포어

- 프로세스가 임계구역 진입 전 스위치 사용으로 놓고 임계구역 진입
- 이후 프로세스는 대기
- 진행 중인 프로세스가 작업 종료 시, 다음 프로세스에게 동기화 신호 보냄
- 세마포어는 정수 값을 가지는 변수
- 세마포어 변수 S를 생성하고 초기값을 설정(보통 사용 가능한 자원의 수).
- P 연산 (wait 또는 down):
  S 값을 확인
  S > 0 이면, S를 1 감소시키고 진행
  S = 0 이면, 프로세스를 대기 큐에 넣고 블록 상태로 만듬
- V 연산 (signal 또는 up):
  S 값을 1 증가
  대기 중인 프로세스가 있으면 그 중 하나를 깨움

### 모니터

- 세마포어의 단점은 잘못된 구현으로 임계구역이 보호받지 못할 수 있음(??)
- 공유자원 사용 시, 모든 프로세스가 세마포어 알고리즘을 따른다면 운영체제가 이를 효과적으로 관리할 수 있음
- 이를 구현한 것이 모니터로, 공유자원을 내부적으로 숨기고 공유자원에 접근하는 인터페이스만 제공
- 시스템 콜 같은 개념

## 4. 심화학습 파일, 파이프, 소켓 프로그래밍

### 파일

- 파일 내 데이터는 개념적으로 한줄로 저장된다.
  - 이를 순차 파일이라 하며, 접근하는 방식은 순차적 접근
  - 파일에는 파일 기술자(FD)가 있음
    - 열린 파일을 추적하기 위해 사용하는 추상화된 핸들
    - 정수값으로 표현되며, 프로세스별로 유니크합니다.
    - 파일 포인터(File Pointer) - 파일 내에서 현재의 읽기/쓰기 위치를 나타내는 오프셋

### 파이프

- 사용방식은 파일과 같음
- 다만 메모리 내에서 동작

### 네트워킹

- 가장 일반적인 것은 소켓을 이용한 네트워킹
- 클라이언트 통신절차
  - 클라이언트가 소켓을 생성 후, 서버와 접속 시도(connect)
  - 서버와 접속 되면 read, write
  - 작업 종료 시, 소켓 기술자(socket descriptor)를 닫고 종료
- 서버 통신 절차
  - 소켓을 생성 후, 특정 포트에 등록(bind)
  - bind 후, 클라이언트의 접속을 받을 준비(listen)
  - 클라이언트의 connect을 받으면 accept
  - 소켓 기술자 생성 및 작업 시작
  - 소켓 기술자를 닫고 다음 클라이언트 대기

이 부분에 대해 클라이언트와 서버가 통신하는 소켓과 최초 커넥션을 관리하는 소켓이 뭔가 분리되어야 할 것 같은데 아래처럼 이해

1. 최초 바인드하는 소켓은 listening 소켓으로 클라이언트들의 요청을 관리
2. connect 요청을 받고 accept하면 내부적으로 새로운 소켓을 생성해 해당 클라이언트와 연결을 맺고 소켓 디스크립터를 반환
