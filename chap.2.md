# 운영체제의 개요

24/05/07 사당에서 스터디 진행

![in twosome](./imgs/240507_twosome.jpeg)

## 1. 컴퓨터의 기본 구성

### 하드웨어

- 필수장치: CPU, 메모리
- 주변장치: 입력, 출력, 저장 장치

### 폰 노이만 구조

- 폰 노이만 구조: 프로그램을 메모리에 저장하고 필요에 따라 프로그램을 교체할 수 있는 현대 컴퓨터 아키텍처의 기반이 되는 구조

  - 이를 통해 하드웨어 구조를 변경하지 않고도 다양한 작업을 수행할 수 있음
  - 모든 프로그램은 메모리에 올라와야 실행 가능(가상메모리 기술로 극복)

### Clock & Hz

- 클록(Clock): 클록은 컴퓨터에서 일정한 주기로 발생하는 규칙적인 신호
  - 클록 신호는 일반적으로 구형파 형태로, 일정한 간격으로 높은 상태(High)와 낮은 상태(Low)를 반복
- 틱(Tick) or 펄스(pulse): 클록 신호의 한 주기를 나타내는 용어
  - 한 틱은 클록 신호가 높은 상태에서 낮은 상태로, 다시 높은 상태로 변화하는 과정을 의미
  - **각 틱마다 CPU는 명령어를 실행하고, 데이터를 처리하며, 다른 구성 요소들과 통신**
- Hz(헤르츠): 시간에 따라 변화가 일어날 때 사용하는 단위

  - 1초에 1,000번 pulse가 일어나면 1KHz(1,000Hz)
  - 3GHz: 1초에 30억번(3 \* 10^9) 연산가능

### 시스템 버스 & CPU 버스

- 시스템 버스(FSB, 전면 버스): CPU, 메모리, 주변장치를 연결하는 버스(메인보드의 속도)
- CPU 내부 버스(BSB, 후면 버스): CPU 내부 장치들을 연결하는 버스(CPU의 속도)

## 2. CPU와 메모리

### CPU 기본 구성

- 산술논리 연산장치(ALU arithmetic and logic unit):사칙연산 및 논리연산 수행
- 제어 장치(control unit):CPU에서 작업을 지시하는 부분을 담당
  - 메모리로부터 데이터 load 및 save, 명령어 관련 제어...
- 레지스터(register): 연산 작업에 필요한 데이터를 CPU 내부에 저장

### 레지스터의 종류

사용자 프로그램에 의해 변경되는 일반 레지스터(user-visible register)

- 데이터 레지스터(data DR): 메모리에서 가져온 데이터를 보관, 대부분 레지스터가 데이터 레지스터
- 주소 레지스터(address AR): 데이터 또는 명령어의 메모리의 주소를 저장

사용자가 변경할 수 없는 특수 레지스터(user-invisible register)

- program/instruction counter: 다음 실행할 명령어의 주소를 기억 -> 제어장치에 전달(명령어 포인터)
- stack pointer:스택의 top을 가리키는 레지스터
  - 스택 메모리는 큰 주소에서 작은 주소로 할당
  - 함수 호출 시 매개변수, 복귀 주소, 지역 변수 등이 스택에 저장될 때 스택 영역이 커지며 주소값 감소
  - 스택에서 데이터를 제거할 때 스택영역이 감소하며 스택 포인터의 주소값 증가
- base/frame pointer: 현재 함수의 스택 프레임 시작 위치를 가리키는 레지스터

  - 함수 호출 시 이전 함수의 BP 값을 스택에 저장
  - 현재 함수의 SP를 BP 값으로 초기화
  - 함수 내에서 지역 변수나 매개변수에 접근할 때 BP를 기준으로 상대적인 오프셋을 사용하여 접근
  - 함수 종료 시 호출시점에 저장한 이전 영역의 BP 값으로 복원하여 이전 스택 프레임으로 돌아감

- 명령어 레지스터(instruction IR): 현재 실행중인 명령어를 저장 -> 제어장치가 해석 후 외부 장치에 제어 신호
- 메모리 주소 레지스터(memory address MAR): 메모리에 데이터를 save&load 할 때, 주소를 지정할 때 사용
- 메모리 버퍼 레지스터(memory buffer MBR): 메모리에 save&load할 데이터를 임시로 저장, MAR과 함께 동작
- 프로그램 상태 레지스터(program state PSR): 분기 처리시, 연산결과를 저장해 제어장치에 실행될 명령어를 알려줌

### 특수 레지스터 동작과정

1. 프로그램 카운터 -> 명령어의 주소를 제어장치에 전달
2. 명령어 레지스터 -> 명령어를 레지스터에 전달
3. 메모리 주소 레지스터 -> 필요한 데이터의 메모리 주소 파악
4. 제어장치가 메모리 관리자에게 load 요청(memory -> cpu)
   - 해당 주소는 논리적인 주소로 MMU(memory management unit)에서 물리적인 주소로 변환
5. 메모리 버퍼 레지스터 -> 메모리로부터 데이터 load
6. 레지스터 -> 제어장치가 메모리 버퍼 레지스터에서 불러온 데이터를 레지스터에 저장

### 버스의 종류

CPU, 메모리, 주변장치들이 데이터를 주고 받을 때, 시스템 버스를 사용한다.

- 제어 버스: 어떤 작업을 할지 지시하는 제어 신호들이 **제어 버스를 통해 제어장치로 전달 됌(양방향)**
  - 메모리에서 데이터 읽기, 쓰기 신호
  - 하드디스크 저장, 사운드카드 소리, 네트워크 카드에 데이터 도착 신호 등...
- 주소 버스: 메모리의 데이터를 읽거나 쓸 때에 관한 위치정보가 **MAR을 통해 메모리나 주변장치로 전달(단방향)**
- 데이터 버스: 제어버스가 어떤 작업을 할지, 주소 버스가 위치 정보를 전달하면, **MBR을 통해 데이터를 목적지로 전달(양방향)**

### CPU 비트의 의미

버스의 대역폭(bandwidth)은 한번에 전달할 수 있는 데이터의 최대 크기로 CPU가 한번에 처리할 수 있는 데이터의 크기와 같다.

64bits CPU라면 버스의 대역폭, 레지스터의 크기, 메모리에 한번에 저장할 수 있는 크기 모두 같다.

64bits CPU는 32 bits 운영체제를 사용할 수 있지만, 32bits CPU는 64 bits운영체제를 사용할 수 없다.

32bits 운영체제에서 사용할 수 있는 메모리의 양은 최대 2^32, 4,294,967,296 bits(4GB)이다.

### 메모리 보호

메모리가 보호되지 않으면, 어떤 프로세스가 타 프로세스의 영역을 침범해 데이터를 지울 수도 있으며 운영체제의 영역을 침범해 버그를 낼 수 있다.

운영체제도 CPU를 사용하는 process로 사용자 프로세스가 CPU를 점유하는 동안 운영체제 프로세스가 잠시 중단 되었을 때,

사용자 작업으로 부터 메모리를 보호하려면 하드웨어의 도움이 필요하다.

CPU는 현재 진행중인 프로세스의 메모리 시작주소를 경계 레지스터(bound)에 마지막 주소를 한계 레지스터(limit)에 저장 후,

데이터를 메모리에서 읽고 쓸 때 프로세스가 할당 받은 주소 범위를 벗어나는지 검사한다.

### 부팅

1. 전원 실행 시,
2. ROM에 저장 된 BIOS(basic io system)이 실행되어
3. 주요 하드웨어 점검 후,
4. 하드디스크의 부트스트랩 코드 실행
5. 운영체제가 메모리에 올라옴

마스터 부트 레코드는 하드디스크의 첫번째 섹터이며 운영체제를 실행하기위한 코드인 부트스트랩이 저장되어 있다.

## 3. 컴퓨터 성능 향상 기술

현대 컴퓨터 구조의 문제점은 각 장치들의 작업속도가 다르다는 점

- 시스템 버스와 CPU 내부 버스의 속도차이
- CPU, 메모리, 하드디스크의 속도차이

### buffer

일정량의 데이터를 모아 한번에 전송하는 방법으로 두 장치간의 속도차이를 완화한다.

하드디스크의 메모리버퍼가 클수록 빠름

### 스풀(SPOOL)

- CPU와 입출력장치가 독립적으로 동작하도록 고안된 소프트웨어적 버퍼로 대표적인 예시는 프린터에 사용되는 스풀러
- 스풀러는 인쇄할 내용을 순차적으로 출력하는 소프트웨어로 출력 명령을 내린 프로그램과 독립적으로 동작
  - 워드 프로세서로 프린트 작업을 할 때, 스풀러가 없다면 출력이 마무리 될 때 까지 워드 프로세서를 사용할 수 없음
  - 문서 작업과 프린터 출력작업이 독립적으로 진행되는 것
- 버퍼는 프로그램들이 공유하지만 스풀은 배타적이다

### cache

- 메모리와 CPU간의 속도차를 완화하기 위해 메모리의 데이터를 미리 가져오는 임시 장소
- CPU 내부 캐시는 CPU 내부 버스의 속도로 동작
  - 원하는 데이터가 캐시에 있으면 히트 없으면 미스
  - 현재 위치와 가까운 데이터가 멀리 있는 데이터보다 사용될 확률이 높다는 지역성이론이 있음
  - 캐시가 변경되면 메모리의 데이터도 변경되어야 함
    - 즉시 쓰기(sync)
    - 지연 쓰기(async)
- L1 cache: 명령어 레지스터에 연결되는 명령어 캐시, 데이터 레지스터에 연결되는 데이터 캐시
- L2: L1보다 메모리와 가까운 캐시, 여기까지는 코어별로 있음
- L3: 모든 CPU 코어가 공유하는 캐시

[관련한 좋은 글](https://quasarzone.com/bbs/qn_hardware/views/818208)

### 저장 장치 계층 구조

비쌀 수록 용량이 작고 빠르기에, 가격과 컴퓨터 성능사이의 타협을 위한 저장 장치 계층구조가 있음.

- 빠르고 비싼 저장 장치는 CPU에 가까이 위치
  - 레지스터, 캐시 메모리 - 용량은 작지만, 속도가 매우 빠르고 비쌈
- 느리고 저렴한 저장 장치는 CPU에서 멀리 위치
  - 주 메모리(RAM), 하드 디스크등 - 상대적으로 저렴

저장 장치의 계층구조에서는 데이터에 대한 일관성이 문제가 될 수 있다.

1. cpu 캐시에서 데이터가 변경되면, 메모리에서의 해당 데이터도 변경되어야함
2. 버퍼를 사용하는 하드디스크에서 버퍼를 비우지 않고 제거 시, 데이터 일관성이 무너짐

### 인터럽트

- 과거에는 CPU에서 입출력 장치에서 데이터를 가져오거나 내보냈는데 이를 polling 방식이라함
- 입출력관리자(장치관리자)가 요청을 받아 작업 완료 후, CPU에게 신호 전달(인터럽트)
- 다양한 종류의 인터럽트가 있음(전원버튼, 키보드 인터럽트...)
- 장치마다 인터럽트 번호가 다름(운영체제마다 다름)

### 직접 메모리 접근(direct memory access)

- 폴링 방식을 사용할 당시는 CPU가 메모리나 주변장치에 대한 접근권한을 가지고 있었음
  - CPU가 지속적으로 장치의 상태를 확인해야 하므로 비효율적
- 효율성을 위해 인터럽트 방식을 사용하면서 입출력관리자라는 역활을 분리
- 입출력관리자는 주변 장치와의 데이터 입출력을 담당
  - 이를 위해 메모리에 직접 접근할 수 있는 권한인 DMA(Direct Memory Access)가 필요
- 입출력관리자가 DMA로 저장하는 데이터들을 위한 메모리 영역을 분리(메모리 맵 입출력)

1. 애플리케이션이 하드 디스크에서 데이터를 읽어오도록 요청
2. 입출력 관리자는 하드 디스크 컨트롤러에게 데이터 읽기 명령을 전달
3. 하드 디스크 컨트롤러는 데이터를 읽어온 후, 인터럽트를 발생시켜 입출력 관리자에게 알립니다.
4. 입출력 관리자는 DMA를 사용하여 하드 디스크 컨트롤러가 읽어온 데이터를 메모리의 특정 영역(디스크 버퍼)에 저장
5. 입출력 관리자는 애플리케이션에게 데이터가 준비되었음을 알리고, 애플리케이션은 해당 메모리 영역에서 데이터를 읽음

## 4. 멀티 프로세싱

### 멀티 코어 시스템

- 과거에는 CPU의 코어가 하나였는데, 코어 하나의 성능이 과거에 비해 크게 오르지 않음

  - 현재 기술로는 발열 문제로 최대 5GHz정도, 캐시의 크기를 늘리면 비용증가
  - 성능 향상을 위해 코어를 여러개 만듦

- 단일 프로세서 시스템: 프로세서 하나가 한번에 하나의 작업을 처리
- 멀티 프로세서 시스템: 여러 프로세서가 여러 작업을 동시에 처리

싱글코어에서 멀티 프로세서 시스템을 구현하려면 많은 변화가 필요하지만,

- 하드웨어적으로 여러 개의 물리적인 CPU를 시스템에 장착, 이를 위한 메인보드 설계와 칩셋 지원

멀티코어를 사용하면 기존의 시스템에서 멀티 프로세서 시스템이 가능하다.

### CPU 멀티스레드

- 하나의 물리적인 코어에서 여러 개의 논리적인 코어(스레드)를 생성하여 명령어를 병렬로 처리하는 기술
- 하나의 물리적인 코어에서 논리적으로 코어를 분할해 명령어를 병렬로 처리하는 인텔의 하이퍼스레딩
- 4개의 멀티코어 CPU가 하이퍼스레딩을 사용한다면 8개의 논리 코어가 한번에 명령어를 8개 처리가능

[뒤로가기](/)
