# 가상 메모리 관리

- 7/16 구글 미팅
- 주요 단원들을 마무리하고 끝을 항해 가는중!

## 1. 요구 페이징

### 요구 페이징의 개요

- 가상 메모리 시스템에서는 현재 실행 되는 프로세스의 필요한 모듈만 우선적으로 메모리에 올림
  - 메모리의 효율적 관리
  - 응답 속도 향상
- 사용자가 요구할 때, 해당 페이지를 메모리로 가져오는 것을 요구 페이징(demand paging)이라고 함
- 필요할 것이라고 예상 되는 페이지를 미리 가져오는 것은 미리 가져오기(pre fetch)

### 페이지 테이블 엔트리의 구조

- 가상 메모리의 크기 = 메모리 + 하드디스크의 스왑 영역
- 페이지 엔트리 구조
  - 페이지 번호 | a | m | v | r | w | x | 프레임 번호
  - access: 접근비트(참조비트) - 페이지가 메모리에 올라온 후 사용된 적 있는 지 여부
  - modified: 변경비트 - 페이지가 메모리에 올라온 후, 데이터 변경이 있었는 지
  - valid: 유효비트(현재비트) - 페이지가 실제 메모리에 있는지
  - read: 접근권한비트(읽기) - 권한 없는 프로세스의 접근 차단
  - write: 접근권한비트(쓰기)
  - execute: 접근권한비트(실행)
  - 프레임 번호: 유효비트 ? 해당 페이지의 물리 메모리 주소 : 스왑영역 내 주소

### 페이지 부재

- page falut: 프로세스가 요청한 페이지가 메모리에 없는 상황
  - 스왑영역에서 해당 페이지를 가져와야 함

## 2. 페이지 교체 알고리즘

- 페이지 펄트 발생 시 스왑영역에서 페이지를 메모리로 가져와야 함
- 메모리가 가득차있다면 기존의 페이지를 스왑영역에 보내야 가져올 수 있음
- 이를 위한 알고리즘

- 무작위 알고리즘: 무작위로 대상 페이지 선정
- FIFO: 처음 올라온 페이지를 선정

- 최적 알고리즘: 미래의 메모리 접근 패턴을 고려해 대상 페이지 선정(이론상)

- 최적 근접 알고리즘

  - LRU: least recently used - 최소 사용 - 페이지에 접근한 시간을 기준으로 대상 페이지 선정
    - 페이지에 접근한 시간을 기록하는 방식으로 구현
    - 카운터에 기반한 구현
    - 참조 비트 시프트 방식
    - LRU의 단점은 접근 시간이나 참조 비트를 유지하기 위한 추가 메모리 공간 필요
  - LFU: least frequently used - 최소 빈도 사용 - 페이지가 사용된 횟수를 기준으로 선정
    - LFU 역시 빈도를 기록하기 위한 추가적인 메모리 소요
  - NUR: not used recently - 최근 미사용 - LRU, LFU와 거의 비슷한 성능을 가지며, 메모리를 덜 사용하는 알고리즘으로 현재 가장 많이 사용 된다.
    - 페이지 마다 2 bits만 사용
      - 참조 비트: 페이지에 접근(read/execute) 하면 1
      - 변경 비트: 페이지가 변경(write/append) 하면 1
    - 모든 페이지는 (참조,변경) 의 상태로 시작해 위 경우 발생시 비트가 변경
    - 대상 페이지 선정은 (0,0), (0,1), (1,0), (1,1) 순으로 선정
    - 모든 페이지가 (1,1)이면 전부(0,0)으로 초기화
  - FIFO 변형
    - 2차 기회 페이지 알고리즘: 특정 페이지 성공 시, 해당 페이지를 큐 맨뒤로 이동
    - 시계 알고리즘: 2차 기회 페이지 알고리즘과 유사하지만, 구현 방식이 다름
      - 시계 알고리즘의 대상 포인터는 쫒겨날 페이지를 가르킴, 성공 시 한칸 내려감
      - 원형 큐를 사용, 각 페이지 별 참조 비트 추가, 페이지 성공 시 참조비트 1로 변경
      - 대상 페이지를 선정할 때, 참조 비트 1이면 0으로 변경 후 다음 페이지 탐색
      - 대상 포인터와 각 페이지 별 참조비트 1개만 필요하지만 복잡하고, 계산량이 많음

- 성능 평가 기준
  - 페이지 부재 횟수
  - 페이지 성공 횟수
  - 유지비용(계산이 많이 필요하거나 메모리를 많이 사용)

## 3. 스레싱과 프레임 할당

### 스레싱

- 메모리 스왑이 너무 자주 발생해, 프로그램이 정지한 것 같은 현상
- 페이지 펄트를 방지해야 하는 중요한 이유는 저장장치별 속도차이로 하드디스크 입출력이 많아지면 느려진다

### 프레임 할당

- 실행중인 프로세스들에 어떻게 프레임을 할당할 것인가
- 정적 할당: 프로세스 실행 초기에 프레임을 할당 받음
  - 균등 할당: 프로세스 크기와 상관없이 사용가능한 프레임을 동일하게 할당
  - 비례 할당: 프로세스 크기에 비례하여 할당
    - 균등 할당보다는 현실적이지만, 프로세스가 얼마만큼 메모리를 요구하는지 정확하게 알수 없음(비디오 플레이어)
    - 사용하지 않을 메모리를 처음부터 확보 - 요구페이징 방식에서는 큰 프로세스도 처음부터 메모리에 모두 올리지 않음
- 동적할당: 프로세스 실행 중에도 필요에 따라 할당하거나 해제
  - 작업 집합 모델: 작업 집합(Working Set)은 프로세스가 특정 시간 간격 동안 자주 참조하는 페이지들의 집합
    - 프로세스의 지역성(Locality) 원리에 기반
  - 페이지 부재 빈도: 페이지 부재 횟수를 기록해, 많으면 추가, 적으면 제거

### 전역 교체와 지역 교체

- 전역교체: 전체 프레임을 대상으로 교체 알고리즘을 적용
  - 전체 시스템의 입장에서 효율적
- 지역교체: 현재 실행중인 프로세스의 프레임을 대상으로 교체 알고리즘 적용
  - 페이지 교체가 다른 프로세스에 영향을 미치지 않음
  - 자주 사용하는 페이지가 옮겨지면 시스템 효율이 떨어질 수 있음
