# CPU 스케줄링

- 24/05/30 부산에서 구글미팅으로 진행

## 1.스케줄링의 개요

- 스케줄링: 여러 프로세스의 상황을 고려하여 CPU & 시스템 자원 할당할지 결정

- CPU 스케줄링(레이어를 나눠서 스케줄링)

  - 고수준: 장기 스케줄링, 작업 스케줄링이라고 함
    - 시스템내의 전체 작업(1개 또는 멀티 프로세스)수를 조절
    - 작업 요청 시, 시스템의 부하를 고려하여 승인 혹은 거부 결정
    - 메인프레임과 같은 큰 시스템에서 일괄 작업 처리할 때 사용
  - 중간수준:
    - 프로세스의 중지(suspend)와 활성(active) 상태를 활용하여 활성화 된 프로세스 수를 조절하여 부하 방지
  - 저수준: 단기 스케줄링
    - 어떤 프로세스에 CPU를 할당할 지, 대기상태로 보낼지 결정
    - 현 시점 CPU 스케줄러는 대부분 중간, 저 수준의 스케줄링으로 구성

- 스케줄링의 목적
  - 공평성: 모든 프로세스가 공평하게 자원을 배정 받아야함
  - 효율성: 시스템 자원이 최대한 활용되어야 함
  - 안정성: 중요 프로세스의 우선 동작 및 시스템 자원을 파괴하는 프로세스에 대해 자원 보호
  - 확장성: 프로세스가 증가해도 시스템이 안정적으로 동작
  - 반응 시간 보장: 적절한 시간 내 프로세스의 요구에 반응
  - 무한 연기 방지: 특정 프로세스가 무한히 연기되면 안됨

## 2.스케줄링 시 고려 사항

- 선점형: 현재 실행 상태에 있는 프로세스의 작업을 중단하고 새로운 작업 시작 가능
  - 시분할 방식 스케줄링에 사용
- 비선점형: 특정 프로세스가 실행 상태에 들어가면 종료되거나 자발적으로 대기 상태에 진입하기 전까지 계속 실행

  - 일괄 작업 방식 스케줄링에 사용

- 프로세스는 크게 커널 프로세스와 일반 프로세스로 나뉨

  - 커널 프로세스의 우선순위는 일반적으로 높다.

- 프로세스는 작업 형태에 따라 아래와 같이 나뉨

  - CPU 집중 프로세스
  - 입출력 집중 프로세스
  - 입출력 집중 프로세스를 먼저 실행하는게 유리 -> 입출력 때문에 대기상태로 넘어가기 때문

- 전면 프로세스: 화면의 맨 앞에 놓인 프로세스
  - 현재 입출력 사용, 사용자와 상호작용 가능
- 후면 프로세스: 사용자와 상호작용이 없는 프로세스

| 우선 순위 높음       | 우선 순위 낮음    |
| -------------------- | ----------------- |
| 커널 프로세스        | 일반 프로세스     |
| 전면 프로세스        | 후면 프로세스     |
| 대화형 프로세스      | 일괄처리 프로세스 |
| 입출력 집중 프로세스 | CPU 집중 프로세스 |

## 3.다중 큐

- 현재 대부분 OS에서는 다단계 피드백 큐 스케줄링을 사용
- 우선순위마다 큐가 있고 프로세스를 우선순위에 해당하는 큐에 삽입
- 우선 순위 할당 방식은 고정(생성 시점)과 변동(계속 변동)
- 대기 상태(입출력 대기)에서도 다중 큐를 사용
  - 같은 입출력을 요규한 프로세스끼리 모아놓음
- 준비 큐는 한번에 프로세스를 하나씩 꺼내 CPU를 할당
- 대기 큐는 여러 프로세스를 한번에 꺼냄(같은 종류의 여러 인터럽트를 한번에 처리)
  - 이를 위해 인터럽트 벡터라는 자료구조 사용

## 4.스케줄링 알고리즘

- 스케줄링 알고리즘 평가 기준
  - CPU 사용률: 전체 시스템 동작중 CPU가 사용된 시간 측정
  - 처리량: 단위 시간당 작업을 마친 프로세스 수
  - 대기 시간: 프로세스가 작업 시작전까지 대기하는 시간
  - 응답 시간: 프로세스 시작 후 첫 번째 출력 또는 반응이 나오는데 걸리는 시간
  - 반환 시간: 프로세스가 종료되어 사용하던 자원을 반환하는데 걸린 시간
- 사용률과 처리량은 계산하기 어려워 주로 대기, 응답, 반환시간을 계산

|------------------------- 반환시간 ------------------------|
|-------------- 응답시간 --------------|
|------- 대기 시간 --------|------------ 실행 시간 -----------|
프로세스 시작(준비 큐) ---> 실행 ---- 첫 반응 ---------------- 종료

- 비선점형 알고리즘

  - FCFS: first come first served - 선입선출
    - 우선순위 동일
  - SJF: shortest job first - 가장 짧은 작업부터 처리
    - 효율성이 좋아짐(FCFS보다 대기시간 짧음)
    - 문제점: 프로세스의 종료시점 알기 힘듦, 공평성 위배(아사)
  - HRN: highest response ratio next
    - SJF에서 아사를 방지하기위한 최고 응답률 우선 알고리즘
    - 대기시간 + CPU 사용시간을 고려하여 우선순위 결정((대기 + CPU 사용) / CPU 사용)

- 선점형 알고리즘
  - 라운드로빈: 타임슬라이스만큼 FCFS
  - SRT: shortest remaining time - 라운드로빈과 SJF를 혼합한 방식
    - 남은 시간이 가장 작은 프로세스를 선택
    - 프로세스의 남은 시간을 계산해야함 + 종료시간 예측 어려움 + 아사 현상
  - 우선순위: 프로세스에 우선순위를 반영하는 스케줄링 알고리즘
    - 선점, 비선점방식 모두 적용가능
    - 고정 우선순위, 변동 우선순위로 나뉨
  - 다단계 큐: multi level queue - 프로세스의 우선순위에 따라 여러 준비 큐를 사용
    - 우선순위가 높은 큐부터 실행하기에 하위 큐의 작업이 실행되지 못할 수 있음
  - 다단계 피드백 큐: multi level feedback queue - 위 방식을 보완한 스케줄링 알고리즘
    - CPU를 사용한 프로세스는 우선순위를 낮춤으로 아사현상 방지
    - 우선순위에 따라 타임 슬라이스 크기를 다르게 할당(우선순위가 낮으면 크게 할당)
    - 현대의 운영체제가 일반적으로 사용하는 방식

## 5.심화학습 인터럽트 처리

- 인터럽트: Interrupt는 현재 실행 중인 프로그램을 중단하고 미리 정의된 인터럽트 처리 루틴을 실행하도록 신호를 보내는 것
- 동기적 인터럽트: 프로세스가 실행중인 명령어로 발생하는 인터럽트
- 비동기적 인터럽트: 사용자 인터럽트(프로레스 종료, 주변장치 조작에 의한 인터럽트등)
- 인터럽트 고유 번호와 그 번호에 붙어있는 함수(핸들러)가 있음
- 한순간에 여러개가 동시에 발생하기도 하는데 이를 한번에 묶어서 처리하는 개념이 인터럽트 벡터
- 인터럽트 처리과정

  - 인터럽트 발생 시, 현재 실행중인 프로세스 일시 정지 및 관련 정보 저장
  - 인터럽트 컨트롤러가 인터럽트의 처리순서를 결정(여러개 동시 발생 시 우선순위 순)
  - 처리할 인터럽트를 결정 후 핸들러 실행
  - 핸들러가 인터럽트 처리를 마치면 일시 정지된 프로세스가 다시 실행되거나 종료(오류 인터럽트 시)

- 프로세스는 커널 프로세스, 사용자 프로세스 두가지로 나뉨
- 운영체제와 관련 된 커널 프로세스가 실행 될 때, 운영체제는 커널모드로 변경
- 사용자 프로세스 실행 시 운영체제는 사용자 모드
- 운영체제가 두 모드(사용자,커널)를 전환하며 일 처리 하는 것을 이중 모드라고함
  - 자원을 보호하기 위해 사용 - 사용자 프로세스가 시스템 자원에 직접 접근하는 것을 방지

[뒤로가기](/)
