# 프로세스와 스레드

- 24/05/24 사당에서 스터디 진행
- 동글이 인도 여행 다녀와서 일정 밀림
- 사당이 고정이 되었다...
- 개발과 직접적인 연관이 있는 내용들이 나오기 시작

## 1. 프로세스의 개요

- 프로세스란 실행을 위해 메모리에 올라온 동적인 상태
- **PCB(process control block)**
  - 프로세스를 처리하기 위한 정보들 저장
    - PID, 메모리 관련정보, 프로세스 상태, 우선순위, 관련 중간 값들(프로그램 카운터, 레지스터 값들)
    - 프로그램이 프로세스가 되었다는 건 운영체제에 PCB를 생성했다는 뜻
    - 프로세스 종료 === PCB 삭제
- 프로세스의 상태
  - create: 프로그램이 메모리에 올라옴 + 운영체제가 PCB 할당
  - ready: ready queue에서 대기중(CPU 스케줄러가 관리)
  - running:
    - 프로세스가 CPU를 할당받아 실행
    - 스케줄러가 프로세스를 실행 상태로 가져옴(dispatch)
    - 주어진 시간(타임 슬라이스)동안 실행
  - blocking: 실행중인 프로세스가 I/O 요청 시, 완료까지 Block
    - 작업 마무리 시(인터럽트), ready queue로 이동
  - terminate: 프로세스 종료 -> 메모리에서 데이터 삭제 & PCB 폐기
  - 위 5가지가 일반적으로 활성 상태라고 불림(active status)
  - pause: 프로세스가 일시적으로 쉬는 상태
  - suspend: 프로세스가 메모리 밖의 swap area에 보관
    - 메모리 꽉찬 경우
    - 프로그램의 오류, 악의적인 프로세스라고 판단될 때, 매우 긴 주기, 입출력 지연...

## 2. 프로세스 제어 블록과 문맥 교환

- **context switching**: cpu를 차지하던 프로세스가 나가고, 새로운 프로세스를 받아들이는 작업
  - 기존의 프로세스의 PCB에 현재까지의 작업내용 저장
  - 실행 상태로 들어오는 프로세스의 PCB의 내용으로 CPU setting
- time splice의 사이즈가 중요함
  - 크면 동시성을 만족하기 어려움
  - 작아질수록 context switching의 비용때문에 운영체제가 프로세스마다 적절한 타임슬라이스를 설정
  - 대략 100 milli(10 ~ 200 milli) second

## 3. 프로세스의 연산

- 프로세스의 구조

  - code area: 명령어 모음(read only)
  - data area: 전역 변수 저장
  - heap area: 동적 메모리 할당을 위해 사용되는 영역
  - stack area: 지역 변수, 함수 호출 시 전달되는 인자, 함수의 반환 주소 등이 저장되는 영역

- 프로세스의 생성하는 방법은 새로운 프로세스를 생성하는 방법도 있지만, 기존의 프로세스를 복사 하는 방법도 있음
- `fork` 시스템 콜은 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수(동일한 프로세스 복사)
  - 실행중이던 프로세스는 부모, 생성된 프로세스는 자식 프로세스가 됌
  - PID, 메모리 관련 정보, CPID등은 다름
  - 이 방식의 장점
    - 프로세스 생성이 새로운 프로세스를 생성하는 것보다 빠름
    - 자식 프로세스 종료 시, 부모 프로세스가 정리할 수 있는데 이는 시스템을 효율적으로 만듦
- `exec` call은 기존 프로세스를 새로운 프로세스로 전환하는 함수
  - 사용 시, code 영역 기존 내용을 지우고 새로운 코드로 변경!, data, stack 영역 초기화
  - 프로세스 구분자(PID,PPID,CPID), 메모리 관련 사항은 변하지 않지만, 레지스터 값 및 사용한 파일 정보 모두 리셋(초기화)
  - 사용목적은 프로세스 구조를 재활용하기 위함
    - 이미 만들어진 PCB, 메모리 영역 사용 및 부모 자식 관계 유지
- 프로세스 계층구조(unix 기준)
  - 동시에 여러 작업을 처리 하며, 종료된 프로세스의 자원을 회수하는데 유용
  - 운영체제는 init 프로세스를 생성 후, 나머지 프로세스들을 init의 자식으로 만듦
    - login process 생성 후, 사용자가 login 시,`exec`으로 login 프로세스를 shell 프로세스로 변경
    - 모든 프로세스가 독립적으로 생성 된다면, 운영체제가 자원을 회수하는 작업이 복잡해질 것
    - 이를 위해 부모 자식간의 관계를 만들고, 부모 프로세스가 자식프로세스의 자원을 종료 시 회수
  - 고아 프로세스(orphan): 부모 프로세스가 먼저 종료 된 자식 프로세스
  - 좀비 프로세스(zombie): 부모 프로세스가 자원을 회수하지 않는 종료 된 자식 프로세스

## 4. 스레드

- 프로세스의 작업과정
  - 운영체제가 코드와 데이터를 메모리에 올리고 PCB 생성
  - 프로세스 생성 및 준비 상태
  - cpu 스케줄러가 프로세스에 cpu 할당(running)
  - **cpu가 처리하는 작업의 단위는 스레드가 된다.**
    - 작업의 크기 job(batch(multi process)) > task(process) > operation(thread)
    - multi task -> multi process
- 스레드의 개념은 상대적으로 나중에 나옴
  - 멀티 코어를 가진 CPU의 등장(프로세스에 하나의 스레드만 있다면 여러코어에 동시에 작업 불가)
  - 멀티스레드: 프로세스의 작업을 여러개의 스레드로 분할
  - 멀티태스킹: CPU에 작업(스레드)을 줄 때, 시간을 잘게 나누어(타임 슬라이스) 배분
  - 멀티 프로세싱: CPU의 여러 코어에 여러 스레드를 배정 및 병렬 처리
- 멀티 스레드의 구조 및 장점
  - Stack 영역을 제외한 나머지 영역 공유
  - 응답성 향상: 한 스레드가 작업이 진행 되지 않아도, 다른 스레드가 동작중
  - 멀티 프로세스보다 효율적
  - 다중 CPU 지원

### 사용자 스레드와 커널 스레드

- 사용자 스레드 (User Thread): 사용자 수준에서 스레드를 관리하는 방식으로, 사용자 스레드 라이브러리를 통해 구현

  - 사용자 모드에서 스레드 생성, 관리, 스케줄링이 이루어집니다.
  - 커널의 지원 없이 사용자 수준에서 스레드 간 전환이 가능합니다.
  - 스레드 전환 시 커널 모드로의 전환이 필요하지 않아 오버헤드가 적습니다.
  - 한 스레드의 블로킹이 다른 스레드에 영향을 주지 않습니다.
  - 커널이 사용자 스레드의 존재를 인식하지 못합니다.
  - 장점
    - 빠른 컨텍스트 스위칭과 적은 오버헤드로 인해 효율적입니다.
    - 사용자 수준에서 스레드를 자유롭게 생성하고 관리할 수 있습니다.
  - 단점
    - 한 스레드가 블로킹 시스템 콜을 호출하면 전체 프로세스가 블로킹됩니다.
    - 다중 프로세서 환경에서 병렬성을 활용하기 어렵습니다.

- 커널 스레드 (Kernel Thread):정의: 운영체제 커널에서 직접 스레드를 관리하는 방식으로, 커널에 의해 지원

  - 커널 모드에서 스레드 생성, 관리, 스케줄링이 이루어집니다.
  - 각 스레드는 독립적인 커널 스케줄링 단위로 취급됩니다.
  - 스레드 전환 시 커널 모드로의 전환이 필요하므로 오버헤드가 발생합니다.
  - 한 스레드의 블로킹이 다른 스레드에 영향을 주지 않습니다.
  - 커널이 스레드의 존재를 인식하고 직접 관리합니다.
  - 장점
    - 블로킹 시스템 콜 호출 시에도 다른 스레드의 실행이 가능합니다.
    - 다중 프로세서 환경에서 진정한 병렬 실행이 가능합니다.
    - 커널에 의해 스케줄링되므로 시스템 전체적인 부하 분산이 가능합니다.
  - 단점
    - 스레드 생성 및 전환에 따른 오버헤드가 사용자 스레드에 비해 큽니다.
    - 커널 모드로의 전환이 필요하므로 빈번한 스레드 전환 시 성능 저하가 발생할 수 있습니다.

- 차이점
  - 구현 위치: 사용자 스레드는 사용자 모드에서, 커널 스레드는 커널 모드에서 구현됩니다.
  - 스케줄링 주체: 사용자 스레드는 사용자 수준 스레드 라이브러리에 의해, 커널 스레드는 운영체제 커널에 의해 스케줄링됩니다.
  - 시스템 자원 접근: 사용자 스레드는 시스템 자원에 직접 접근할 수 없지만, 커널 스레드는 시스템 자원에 직접 접근할 수 있습니다.
  - 병렬성: 사용자 스레드는 한 프로세서 내에서 병렬성을 제공하지만, 커널 스레드는 다중 프로세서 환경에서 진정한 병렬 실행이 가능합니다.
  - 컨텍스트 스위칭 오버헤드: 사용자 스레드는 컨텍스트 스위칭 오버헤드가 적지만, 커널 스레드는 상대적으로 오버헤드가 큽니다.
  - 블로킹의 영향: 사용자 스레드에서 한 스레드의 블로킹이 전체 프로세스를 블로킹시킬 수 있지만, 커널 스레드에서는 한 스레드의 블로킹이 다른 스레드에 영향을 주지 않습니다.

### 멀티 스레드 모델

- 1 to N 모델(사용자 스레드)
  - 커널 스레드 1개, 사용자 스레드 N 개
  - 커널이 멀티스레드를 지원 하지않는 초기 시스템
  - 사용자 스레드 라이브러리가 스케줄링이나 동기화 같은 작업 처리
  - 커널의 입장에서는 하나의 프로세스
  - 여러 CPU 코어 동시 사용불가
- 1 to 1 모델(커널 스레드)
  - 1 to N 모델과 반대
- M to N 모델(멀티레벨 스레드)
  - 커널 스레드 갯수 <= 사용자 스레드
  - 위 두가지의 혼합

## 5. 심화학습 동적 할당 영역과 시스템 호출

- heap area: 동적으로 할당 되는 변수의 영역
- PCB의 제어블록 큐는 배열의 크기를 알 수 없기 때문에 링크드 리스트의 방식
  - head: pointer
  - tail: PCB

[뒤로가기](/)
