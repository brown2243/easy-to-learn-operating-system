# 물리 메모리 관리

- 24/06/13 사당 투썸
- 실수로 직원한데 커피 쏟았는데 또 가게 될까

## 1. 메모리 관리의 개요

### 메모리 이해하기

- 메모리는 1 바이트(8 bits) 크기로 나뉜다.
- 나뉜 각 영역은 주소로 구분 되는데 0번지부터 시작
- CPU가 CPU안의 레지스터에 접근하는 것(1 ~ 2 clock)보다 몇 배이상 느림(10 clock 이상)
- 속도 차이를 극복하기 위해 CPU안에 캐시 만들어두고 미리 가져옴

### 매모리 관리의 이중성

- 메모리 관리는 MMS(memory management system)이 관리
- 메모리 관리는 일괄처리 시스템에서는 간단하지만 시분할 시스템에서는 복잡함
- 매모리 관리의 이중성:
  - 프로세스 입장에서는 가용 메모리가 많을 수록 좋음
  - 메모리 관리자 입장에서는 효율적으로 할당 하려는 것의 충돌

### 소스코드의 번역과 실행

- 저급언어: 컴퓨터의 동작을 직접적으로 표현한 언어(기계어,어셈블리어)
- 고급언어: 사용자가 이해하기 쉽게 프로그래밍 할 수 있는 언어(C,JS, Java~~)
- 고급언어로 작성한 소스코드를 컴퓨터가 실행할 수 있는 기계어로 번역

  - 컴파일러: 소스코드를 한꺼번에 번역 후 한번에 실행
  - 인터프리터: 한줄 씩 번역하여 실행

- 컴파일러 방식의 특징

  - 컴파일 시점에 오류 발견 가능
  - 소스코드 최적화 가능

- 컴파일 과정
  1. 오류 점검 및 불필요한 변수 코드 삭제
  2. 목적코드로 변환(실행 전 단계의 코드, 기계어 상태)
  3. 사용중인 라이브러리 코드를 목적 코드에 삽입 or 외부 라이브러리 연결(linking)
  4. 최종 실행파일

### 메모리 관리 작업

- 가져오기(fetch): 실행할 프로세스와 데이터를 메모리로 가져옴
- 배치(placement): 가져온 프로세스와 데이터를 메모리 어떤 부분에 올릴지 결정
  - 같은 크기로 자르면 paging, 프로세스의 크기에 맞춰 자르면 segmentation
- 재배치(replacement): 메모리가 가득 차면 오래 된 프로세스를 내보내고 새로운 프로세스를 가져옴

## 2. 메모리 주소

메모리에 접근할 때 주소를 사용하고, 주소는 물리, 논리주소로 나뉜다.

### 32 bits CPU와 64 bits CPU의 차이

- CPU가 한번에 다를 수 있는 데이터의 크기를 의미
- CPU 내부 부품은 모두 이 비트를 기준으로 제작
- 32 bits 운영체제에서는 메모리를 대략 4GB 까지 사용가능
  - 메모리 주소의 범위가 0 ~ 2 ** 32 - 1 (`2 ** 32B === 약 4GB`)

### 논리 주소와 물리 주소

- 메모리 관리자는 메모리를 운영체제 영역, 사용자 영역으로 나누어 관리
  - 0 ~ 1000이라면 0 ~ 300 까지 운영체제, 사용자 영역은 1000부터 내려가며 사용 됨
- 사용자 영역이 운영체제의 영역으로 침범하는 것을 막기위해 CPU내 경계 레지스터가 담당

  - 경계지점 주소를 들고있다가, 메모리에 접근할 때마다 주소 값 비교

- 프로세스는 논리주소를 사용하는데 이를 물리 주소로 변환하는 작업이 필요
- 이는 CPU 내부의 MMU(memory management unit)가 담당
  1. 사용자 프로세스가 논리 주소 40번지에 있는 데이터 요청
  2. CPU는 MMU에게 이를 요청
  3. MMU는 재배치 레지스터를 사용해 물리 메모리 400번지에서 데이터를 가져옴

## 3. 단일 프로그래밍 환경의 메모리 할당

### 메모리 오버레이

- 전체 프로그램을 한번에 메모리로 가져오는 대신 적당한 크기로 잘라 필요한 부분부터 가져오는 기법
- 메모리보다 큰 프로그램도 실행 가능
- 어떤 모듈을 가져오거나 내보낼 지는 프로그램 카운터(PC)가 결정
  - 실행할 명령어의 위치를 가르키는 레지스터

### 스왑

- 위 처럼 동작하려면 모듈이 스왑 되는 로직이 필수적
- 메모리가 모자라 쫒겨나는 프로세스들은 하드디스크의 특별한 영역에 모임(스왑 영역)
- 스왑 영역에서 메모리로 swap in, swap out

## 4. 다중 프로그래밍 환경의 메모리 할당

### 메모리 분할 방식

- 메모리를 어떤 크기로 나눌지는 배치 정책

  - 가변 분할 방식: 프로세스의 크기에 따라 나눔

    - 연속적 메모리 할당
    - 메모리 관리가 복잡
    - 세그먼테이션 메모리 관리기법
    - 외부 단편화: 메모리 단편화가 프로세스의 바깥에 위치

  - 고정 분할 방식: 같은 크기로 나눔
    - 비연속 메모리 할당
    - 메모리 관리가 쉬움
    - 페이징 메모리 관리기법
    - 내부 단편화: 메모리 단편화가 프로세스의 안쪽에 위치
    - **현대 운영체제에서 기본적으로 사용**

### 가변 분할 방식의 메모리 관리

- 메모리 배치 방식
  - 최초 배치, 최적 배치, 최악 배치
- 조각모음: 외부 단편화로 남는 메모리 공간을 합치는 작업

### 분할 방식의 메모리 관리

- 내부 단편화: 각 메모리 조각에 프로세스를 배치할 때 남는 부분이 생길 수 있음

## 5. 심화학습 분할 컴파일과 메모리 관리

### 분할 컴파일

- 소스코드는 컴파일을 거쳐 목적 코드가 된다
- 다중 소스 코드: 여러 소스코드 파일을 사용해 하나의 실행 파일을 만드는 것
- 분할 컴파일: 여러개의 소스코드를 각각 컴파일하여 하나의 실행파일로 만듦
  - 목적 코드 상태로 파일을 받아 본인의 목적 코드와 컴파일 -> 실행파일
  - 서로 다른 목적 코드를 하나로 만드는 단계를 연결 단계라 함
